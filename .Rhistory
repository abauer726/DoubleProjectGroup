ggtitle("A conditioned Boxplot of Algal a3") +
geom_boxplot()
algae3
# factor(levels = c("high", "medium", "low"))
# I reorder the groups order : I change the order of the factor data$names
speednames <- factor(algae$names , levels=c("high", "medium", "low"))
#The plot is now ordered !
# oxplot(algae$a3 ~ speednames,  ylab="value" ,
# xlab="names in desired order")
median_col <- cbind(
lapply(algae[4:11], FUN = median, na.rm = T)
)
mad_col <- cbind(
lapply(algae[4:11], FUN = mad, na.rm = T)
)
knitr::kable(list(median_col))
knitr::kable(list(mad_col))
median_col <- cbind(
lapply(algae[4:11], FUN = median, na.rm = T)
)
mad_col <- cbind(
lapply(algae[4:11], FUN = mad, na.rm = T)
)
knitr::kable(list(median_col))
knitr::kable(list(mad_col))
knitr::opts_chunk$set(echo = TRUE) #knitting functions
library(knitr) # library for knit
# set global chunk options: images will be 7x5 inches
knitr::opts_chunk$set(fig.width=7, fig.height=5)
options(digits = 4)
library(tidyverse) # tidyverse library
# install.packages("dplyr")
library(dplyr)
algae <- read_table2("algaeBloom.txt", col_names= c('season','size','speed','mxPH','mn02','C1','NO3','NH4','cPO4','PO4','CHla','a1','a2','a3','a4','a5','a6','a7'), na = "XXXXXXX")
glimpse(algae)
dim(algae)
algae %>% # algae dataset
group_by(size) %>% #group by size
summarise(n = n())  #summarse function to get # of observations
mean_col <- cbind(
lapply(algae[4:11], FUN = mean, na.rm = T) # use lapply
) # define function for the mean of each column in algae
var_col <- cbind(
lapply(algae[4:11], FUN = var, na.rm = T) # use lapply
) # define function for the variance of each column in algae
knitr::kable(list(mean_col))
knitr::kable(list(var_col))
algae1 <- algae %>%
ggplot(aes(mn02, y = after_stat(density))) +
ggtitle("Histogram of mn02") +
geom_histogram(aes(mn02)) # define new object using ggplot to make a histogram
algae1
algae1 <- algae %>%
ggplot(aes(mn02, y = after_stat(probability))) +  #include probability instead of count
ggtitle("Histogram of mn02") + # include title
geom_histogram(aes(mn02)) # define new object using ggplot to make a histogram
algae1
algae1 <- algae %>%
ggplot(aes(mn02, y = after_stat(density))) +  #include probability instead of count
ggtitle("Histogram of mn02") + # include title
geom_histogram(aes(mn02)) # define new object using ggplot to make a histogram
algae1
algae1 + geom_density() + geom_rug() # add density curve to
algae1 + geom_density() # add density curve to
algae3 <- algae1 + geom_density() # add density curve to
algae3 <- algae1 + geom_density() # add density curve to
algae3 + geom_rug()
algae1 + geom_rug()
algae4 <- algae1 + geom_density() # add density curve to
algae %>%
ggplot(aes(mn02, y = after_stat(density))) +  #include probability instead of count
ggtitle("Histogram of mn02") + # include title
geom_rug()
algae4 <- algae1 + geom_density() # add density curve to
algae %>%
ggplot(aes(mn02)) +  #include probability instead of count
ggtitle("Histogram of mn02") + # include title
geom_rug()
algae4 <- algae1 + geom_density() # add density curve to
algae %>%
ggplot(aes(mn02)) +  #include probability instead of count
ggtitle("Histogram of mn02") + # include title
geom_histogram(aes(mn02)) +
geom_density() +
geom_rug()
algae4 <- algae1 + geom_density() # add density curve to
algae %>%
ggplot(aes(mn02, y = after_stat(density))) +  #include probability instead of count
ggtitle("Histogram of mn02") + # include title
geom_histogram(aes(mn02)) +
geom_density() +
geom_rug()
algae4 <- algae1 + geom_density() # add density curve to
algae %>%
ggplot() +
geom_histogram(data=mn02, aes(posttest, ..density..) ) +
geom_density(data=mn02, aes(posttest, ..density..) ) +
geom_rug(data=mn02, aes(posttest) )
algae4 <- algae1 + geom_density() # add density curve to
algae %>%
ggplot() +
geom_histogram(data=algae$mn02, aes(posttest, ..density..) ) +
geom_density(data=algae$mn02, aes(posttest, ..density..) ) +
geom_rug(data=algae$mn02, aes(posttest) )
algae4 <- algae1 + geom_density() # add density curve to
algae %>%
ggplot(aes(mn02, y = after_stat(density))) +  #include probability instead of count
ggtitle("Histogram of mn02") + # include title
geom_histogram(aes(mn02, y = after_stat(density))) +
geom_density(aes(mn02, y = after_stat(density))) +
geom_rug(aes(mn02, y = after_stat(density)))
algae4 <- algae1 + geom_density() # add density curve to
algae %>%
ggplot(aes(mn02)) +  #include probability instead of count
ggtitle("Histogram of mn02") + # include title
geom_histogram(aes(mn02, y = after_stat(density))) +
geom_density(aes(mn02, y = after_stat(density))) +
geom_rug(aes(mn02, y = after_stat(density)))
algae4 <- algae1 + geom_density() # add density curve to
algae %>%
ggplot(aes(mn02, y = after_stat(density))) +  #include probability instead of count
ggtitle("Histogram of mn02") + # include title
geom_histogram(aes(mn02)) +
geom_density(aes(mn02, y = after_stat(density))) +
geom_rug(aes(mn02, y = after_stat(density)))
algae4 <- algae1 + geom_density() # add density curve to
algae %>%
ggplot(aes(mn02)) +  #include probability instead of count
ggtitle("Histogram of mn02") + # include title
geom_histogram(aes(mn02)) +
geom_density(aes(mn02, y = after_stat(density))) +
geom_rug(aes(mn02, y = after_stat(density)))
algae4 <- algae1 + geom_density() # add density curve to
algae %>%
ggplot(aes(mn02)) +  #include probability instead of count
ggtitle("Histogram of mn02") + # include title
geom_histogram(aes(mn02)) +
geom_density(aes(mn02, y = after_stat(density))) +
geom_rug(aes(mn02))
algae4 <- algae1 + geom_density() # add density curve to
algae %>%
ggplot(aes(mn02)) +  #include probability instead of count
ggtitle("Histogram of mn02") + # include title
geom_histogram(aes(mn02)) +
geom_density(aes(mn02)) +
geom_rug(aes(mn02))
algae4 <- algae1 + geom_density() # add density curve to
algae %>%
ggplot(aes(mn02)) +  #include probability instead of count
ggtitle("Histogram of mn02") + # include title
geom_histogram(aes(mn02)) +
geom_density(aes(mn02)) +
geom_rug(aes(mn02))
algae4 <- algae1 + geom_density() # add density curve to
algae %>%
ggplot(aes(mn02, y = after_stat(density))) +  #include probability instead of count
ggtitle("Histogram of mn02") + # include title
geom_histogram(aes(mn02)) +
geom_density(aes(mn02)) +
geom_rug(aes(mn02))
algae4 <- algae1 + geom_density() # add density curve to
algae %>%
ggplot(aes(mn02, y = after_stat(density))) +  #include probability instead of count
ggtitle("Histogram of mn02") + # include title
geom_histogram(aes(mn02)) +
geom_density() +
geom_rug(aes(mn02))
algae4 <- algae1 + geom_density() # add density curve to
algae %>%
ggplot(aes(mn02, y = after_stat(density))) +  #include probability instead of count
ggtitle("Histogram of mn02") + # include title
geom_histogram() +
geom_density() +
geom_rug(aes(mn02))
algae4 <- algae1 + geom_density() # add density curve to
algae %>%
ggplot(aes(mn02, y = after_stat(density))) +  #include probability instead of count
ggtitle("Histogram of mn02") + # include title
geom_histogram() +
geom_density() +
geom_rug()
ggplot(data=algae) +
geom_histogram(aes(mn02, y = after_stat(density))) +
geom_density(aes(mn02, y = after_stat(density))) +
geom_rug(aes(mn02) )
energy <- ggplot(music,aes(x=energy,y=popularity))+geom_point()
library(spotifyr)
library(tidyverse)
library(knitr)
library(lubridate)
library(httpuv)
music <- read.csv("/Users/Grant/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv")
music <- read.csv("/Users/Grant/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv")
music <- read.csv("131 Project/Spotify Dataset/.musicdata.csv.icloud")
music <- read.csv("/Users/kimbauer/Desktop/musicdata.csv")
music <- read.csv("https://github.com/abauer726/DoubleProjectGroup/blob/main/131%20Project/Spotify%20Dataset/musicdata.csv")
music <- read.csv("131 Project/Spotify Dataset/musicdata.csv")
music <- read.csv("https://github.com/abauer726/DoubleProjectGroup/blob/4a0f859d6beea24dd0d523f76a88533eabd11ed8/131%20Project/Spotify%20Dataset/musicdata.csv")
music <- read.csv("https://github.com/abauer726/DoubleProjectGroup/blob/4a0f859d6beea24dd0d523f76a88533eabd11ed8/131%20Project/Spotify%20Dataset/musicdata.csv")
music <- read.csv("131 Project/Spotify Dataset/musicdata.csv")
music <- read.csv("131 Project/Spotify Dataset/musicdata.csv")
music <- read.csv("https://github.com/abauer726/DoubleProjectGroup/blob/main/131%20Project/Spotify%20Dataset/musicdata.csv")
music <- read.csv("/Users/lexnavarra/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv")
library(spotifyr)
library(tidyverse)
library(knitr)
library(lubridate)
library(httpuv)
library(cluster)
library(factoextra)
music <- read.csv("/Users/lexnavarra/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv")
library(spotifyr)
library(tidyverse)
library(knitr)
library(lubridate)
library(httpuv)
library(cluster)
library(factoextra)
music <- read.csv("/Users/lexnavarra/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv")
vector <-[;a', 'b'']
df <- df$vector
vector <- [;a', 'b'']
df <- df$vector
vector <- ['a', 'b']
df <- df$vector
vector <- ('a', 'b')
df <- df$vector
vector <- c(['a', 'b'])
df <- df$vector
vector <- c('a', 'b')
df <- df$vector
print(df)
vector1 <- c('a', 'b')
vector2 <- c('a', 'b')
vector3 <- c('a', 'b')
vector4 <- c('a', 'b')
df <- df$vector
print(df)
df <- data.frame (first_column  = c(vector1, vector2),
second_column = c(vector3, vector4)
)
print(df)
df
vector1 <- [c('a', 'b')]
vector2 <- c('a', 'b')
vector3 <- c('a', 'b')
vector4 <- c('a', 'b')
df <- data.frame (first_column  = c(vector1, vector2),
second_column = c(vector3, vector4)
)
df
library(spotifyr)
library(tidyverse)
library(knitr)
library(lubridate)
library(httpuv)
library(cluster)
library(factoextra)
library(data.table)
library(dplyr)
music <- read.csv("/Users/lexnavarra/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv")
library(spotifyr)
library(tidyverse)
library(knitr)
library(lubridate)
library(httpuv)
library(cluster)
library(factoextra)
library(data.table)
library(dplyr)
music <- read.csv("/Users/Grant/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv")
View(music)
# New research question: can we predict if a song will be a hit based on its attributes? Response variable: song.hotttnesss
# anna path name: /Users/kimbauer/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/data_w_genres.csv
# randomly subset syntax, with 100 points (couldnt run this due to the file not loading)
# anna path name music: /Users/kimbauer/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv
# anna path name music w genre: /Users/kimbauer/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/data_w_genres.csv
# grant path name music: /Users/Grant/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv
# grant path name music w genre: /Users/Grant/DoubleProjectGroup/131 Project/Spotify Dataset/data_w_genres.csv
# lex path name music: /Users/lexnavarra/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv
# lex path name music w genre: /Users/lexnavarra/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/data_w_genres.csv
# creating a new numeric variable for specific artist average popularity
artist_pop_table <- aggregate(music$popularity, list(music$artists), FUN = mean)
full_merge <- merge(x = music, y = artist_pop_table, by.x = c("artists"), by.y = c("Group.1"), all.x = TRUE)
full_data <- rename(full_merge, avg_art_pop = x)
View(full_data)
set.seed((666))
# sample data to use for exploratory graphics
sample <- full_data[sample(nrow(full_data), 200), ]
View(sample)
# some EDA plots to decide which predictor to add into our recipe
valence <- ggplot(sample, aes(x=valence, y=popularity)) + geom_point()
valence
year <- ggplot(sample, aes(x=year, y = popularity)) + geom_point()
year
acousticness <- ggplot(sample, aes(x=acousticness, y=popularity)) + geom_point()
acousticness
danceability <- ggplot(sample, aes(x=danceability, y=popularity)) + geom_point()
danceability
duration <- ggplot(sample, aes(x=duration_ms, y=popularity)) + geom_point()
duration
energy <- ggplot(sample, aes(x=energy, y=popularity)) + geom_point()
energy
explicit <- ggplot(sample, aes(x=explicit)) + geom_bar() + scale_x_continuous(breaks = c(0,1), labels=c("0" = "Clean", "1" = "Explicit"))
explicit
instrumentalness <- ggplot(sample, aes(x=instrumentalness, y=popularity)) + geom_point()
instrumentalness
key <- ggplot(sample, aes(x=key)) + geom_bar() + scale_x_continuous(breaks=0:11,
labels=c("C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"))
key
liveness <- ggplot(sample, aes(x=liveness, y=popularity)) + geom_point()
liveness
loudness <- ggplot(sample, aes(x=loudness, y=popularity)) + geom_point()
loudness
mode <- ggplot(sample, aes(x=mode)) + geom_bar() + scale_x_continuous(breaks=0:1,
labels=c("Minor", "Major"))
mode
speechiness <- ggplot(sample, aes(x=speechiness, y=popularity)) + geom_point()
speechiness
tempo <- ggplot(sample, aes(x=tempo, y=popularity)) + geom_point()
tempo
avg_art_pop <- ggplot(sample, aes(x=avg_art_pop, y=popularity)) + geom_point()
avg_art_pop
# columns not included = artists, id, name, release_date
library(spotifyr)
library(tidyverse)
library(tidymodels)
library(knitr)
library(lubridate)
library(httpuv)
library(cluster)
library(factoextra)
library(data.table)
library(dplyr)
library(ggplot2)
library(BART)
library(gbm)
library(kknn)
library(earth)
library(caret)
library(FNN)
library("ggpubr")
theme_set(
theme_bw() +
theme(legend.position = "top")
)
trainmars <- train
# implementation of MARS method
# divide dataset into k pieces
# fit a regression model to each piece
# use k-fold cross validation to choose a value for k
# using train
#create a tuning grid
hyper_grid <- expand.grid(degree = 1:3,
nprune = seq(2, 50, length.out = 10) %>%
floor())
#make this example reproducible
set.seed(1)
#fit MARS model using k-fold cross-validation
cv_mars <- train(
x = subset(trainmars, select = -c(popularity)),
y = train$popularity,
method = "earth",
metric = "RMSE",
trControl = trainControl(method = "cv", number = 10),
tuneGrid = hyper_grid)
trainmars <- train
# implementation of MARS method
# divide dataset into k pieces
# fit a regression model to each piece
# use k-fold cross validation to choose a value for k
# using train
#create a tuning grid
hyper_grid <- expand.grid(degree = 1:3,
nprune = seq(2, 50, length.out = 10) %>%
floor())
#make this example reproducible
set.seed(1)
#fit MARS model using k-fold cross-validation
cv_mars <- train(
x = subset(trainmars, select = -c(popularity)),
y = train$popularity,
method = "earth",
metric = "RMSE",
trControl = trainControl(method = "cv", number = 10),
tuneGrid = hyper_grid)
music <- read.csv("/Users/kimbauer/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv")
View(music)
# New research question: can we predict if a song will be a hit based on its attributes? Response variable: song.hotttnesss
# anna path name: /Users/kimbauer/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/data_w_genres.csv
# creating a new numeric variable for specific artist average popularity
artist_pop_table <- aggregate(music$popularity, list(music$artists), FUN = mean)
full_merge <- merge(x = music, y = artist_pop_table, by.x = c("artists"), by.y = c("Group.1"), all.x = TRUE)
full_data <- rename(full_merge, avg_art_pop = x)
View(full_data)
set.seed((666))
# sample data to use for exploratory graphics
sample <- full_data[sample(nrow(full_data), 200), ]
View(sample)
# modifying our full data to leave out the variables we don't want
full_data$popularity <- as.numeric(full_data$popularity)
full_data$year <- as.numeric(full_data$year)
full_data$duration_ms <- as.numeric(full_data$duration_ms)
full_data2 = full_data %>%
mutate(explicit = as.factor(ifelse(explicit == 0, "Clean", "Explicit"))) %>%
mutate(mode = as.factor(ifelse(mode == 0, "Minor", "Major")))
delete <- c("artists", "id", "key", "name", "release_date")
full_data <- full_data[!(names(full_data) %in% delete)]
# split training and testing data
#set seed
set.seed(123)
# Sample 700 observations as training data
trainsample = sort(sample(nrow(full_data), nrow(full_data)*.7))
# define dat.train as the 700 observstions
train = full_data[trainsample,]
# The rest as test data
test = full_data[-trainsample,]
trainmars <- train
# implementation of MARS method
# divide dataset into k pieces
# fit a regression model to each piece
# use k-fold cross validation to choose a value for k
# using train
#create a tuning grid
hyper_grid <- expand.grid(degree = 1:3,
nprune = seq(2, 50, length.out = 10) %>%
floor())
#make this example reproducible
set.seed(1)
#fit MARS model using k-fold cross-validation
cv_mars <- train(
x = subset(trainmars, select = -c(popularity)),
y = train$popularity,
method = "earth",
metric = "RMSE",
trControl = trainControl(method = "cv", number = 10),
tuneGrid = hyper_grid)
#display model with lowest test RMSE
cv_mars$results %>%
filter(nprune==cv_mars$bestTune$nprune, degree =cv_mars$bestTune$degree)
#display model with lowest test RMSE
cv_mars$results %>%
filter(nprune= cv_mars$bestTune$nprune, degree = cv_mars$bestTune$degree)
library(spotifyr)
library(tidyverse)
library(tidymodels)
library(knitr)
library(lubridate)
library(httpuv)
library(cluster)
library(factoextra)
library(data.table)
library(dplyr)
library(ggplot2)
library(BART)
library(gbm)
library(kknn)
library(earth)
library(caret)
library(FNN)
library("ggpubr")
theme_set(
theme_bw() +
theme(legend.position = "top")
)
music <- read.csv("/Users/kimbauer/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv")
View(music)
# New research question: can we predict if a song will be a hit based on its attributes? Response variable: song.hotttnesss
# anna path name: /Users/kimbauer/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/data_w_genres.csv
# creating a new numeric variable for specific artist average popularity
artist_pop_table <- aggregate(music$popularity, list(music$artists), FUN = mean)
full_merge <- merge(x = music, y = artist_pop_table, by.x = c("artists"), by.y = c("Group.1"), all.x = TRUE)
full_data <- rename(full_merge, avg_art_pop = x)
# creating a new numeric variable for specific artist average popularity
artist_pop_table <- aggregate(music$popularity, list(music$artists), FUN = mean)
full_merge <- merge(x = music, y = artist_pop_table, by.x = c("artists"), by.y = c("Group.1"), all.x = TRUE)
full_data <- rename(full_merge, avg_art_pop = x)
set.seed((666))
# sample data to use for exploratory graphics
sample <- full_data[sample(nrow(full_data), 200), ]
# modifying our full data to leave out the variables we don't want
full_data$popularity <- as.numeric(full_data$popularity)
full_data$year <- as.numeric(full_data$year)
full_data$duration_ms <- as.numeric(full_data$duration_ms)
full_data2 = full_data %>%
mutate(explicit = as.factor(ifelse(explicit == 0, "Clean", "Explicit"))) %>%
mutate(mode = as.factor(ifelse(mode == 0, "Minor", "Major")))
delete <- c("artists", "id", "key", "name", "release_date")
full_data <- full_data[!(names(full_data) %in% delete)]
# split training and testing data
#set seed
set.seed(123)
# Sample 700 observations as training data
trainsample = sort(sample(nrow(full_data), nrow(full_data)*.7))
# define dat.train as the 700 observstions
train = full_data[trainsample,]
# The rest as test data
test = full_data[-trainsample,]
#display model with lowest test RMSE
cv_mars$results %>%
filter(nprune= cv_mars$bestTune$nprune, degree = cv_mars$bestTune$degree)
#display model with lowest test RMSE
cv_mars$results %>%
filter(nprune == cv_mars$bestTune$nprune, degree = cv_mars$bestTune$degree)
#display model with lowest test RMSE
cv_mars$results %>%
filter(nprune == cv_mars$bestTune$nprune, degree = cv_mars$bestTune$degree)
#display model with lowest test RMSE
cv_mars$results %>%
filter(nprune == cv_mars$bestTune$nprune, degree == cv_mars$bestTune$degree)
#display test RMSE by terms and degree
ggplot(cv_mars)
