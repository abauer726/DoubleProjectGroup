library(factoextra)
library(data.table)
library(dplyr)
music <- read.csv("/Users/lexnavarra/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv")
library(spotifyr)
library(tidyverse)
library(knitr)
library(lubridate)
library(httpuv)
library(cluster)
library(factoextra)
library(data.table)
library(dplyr)
music <- read.csv("/Users/Grant/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv")
View(music)
# New research question: can we predict if a song will be a hit based on its attributes? Response variable: song.hotttnesss
# anna path name: /Users/kimbauer/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/data_w_genres.csv
# randomly subset syntax, with 100 points (couldnt run this due to the file not loading)
# anna path name music: /Users/kimbauer/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv
# anna path name music w genre: /Users/kimbauer/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/data_w_genres.csv
# grant path name music: /Users/Grant/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv
# grant path name music w genre: /Users/Grant/DoubleProjectGroup/131 Project/Spotify Dataset/data_w_genres.csv
# lex path name music: /Users/lexnavarra/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv
# lex path name music w genre: /Users/lexnavarra/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/data_w_genres.csv
# creating a new numeric variable for specific artist average popularity
artist_pop_table <- aggregate(music$popularity, list(music$artists), FUN = mean)
full_merge <- merge(x = music, y = artist_pop_table, by.x = c("artists"), by.y = c("Group.1"), all.x = TRUE)
full_data <- rename(full_merge, avg_art_pop = x)
View(full_data)
set.seed((666))
# sample data to use for exploratory graphics
sample <- full_data[sample(nrow(full_data), 200), ]
View(sample)
# some EDA plots to decide which predictor to add into our recipe
valence <- ggplot(sample, aes(x=valence, y=popularity)) + geom_point()
valence
year <- ggplot(sample, aes(x=year, y = popularity)) + geom_point()
year
acousticness <- ggplot(sample, aes(x=acousticness, y=popularity)) + geom_point()
acousticness
danceability <- ggplot(sample, aes(x=danceability, y=popularity)) + geom_point()
danceability
duration <- ggplot(sample, aes(x=duration_ms, y=popularity)) + geom_point()
duration
energy <- ggplot(sample, aes(x=energy, y=popularity)) + geom_point()
energy
explicit <- ggplot(sample, aes(x=explicit)) + geom_bar() + scale_x_continuous(breaks = c(0,1), labels=c("0" = "Clean", "1" = "Explicit"))
explicit
instrumentalness <- ggplot(sample, aes(x=instrumentalness, y=popularity)) + geom_point()
instrumentalness
key <- ggplot(sample, aes(x=key)) + geom_bar() + scale_x_continuous(breaks=0:11,
labels=c("C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"))
key
liveness <- ggplot(sample, aes(x=liveness, y=popularity)) + geom_point()
liveness
loudness <- ggplot(sample, aes(x=loudness, y=popularity)) + geom_point()
loudness
mode <- ggplot(sample, aes(x=mode)) + geom_bar() + scale_x_continuous(breaks=0:1,
labels=c("Minor", "Major"))
mode
speechiness <- ggplot(sample, aes(x=speechiness, y=popularity)) + geom_point()
speechiness
tempo <- ggplot(sample, aes(x=tempo, y=popularity)) + geom_point()
tempo
avg_art_pop <- ggplot(sample, aes(x=avg_art_pop, y=popularity)) + geom_point()
avg_art_pop
# columns not included = artists, id, name, release_date
library(spotifyr)
library(tidyverse)
library(tidymodels)
library(knitr)
library(lubridate)
library(httpuv)
library(cluster)
library(factoextra)
library(data.table)
library(dplyr)
library(ggplot2)
library(BART)
library(gbm)
library(kknn)
library(earth)
library(caret)
library(FNN)
library("ggpubr")
theme_set(
theme_bw() +
theme(legend.position = "top")
)
trainmars <- train
# implementation of MARS method
# divide dataset into k pieces
# fit a regression model to each piece
# use k-fold cross validation to choose a value for k
# using train
#create a tuning grid
hyper_grid <- expand.grid(degree = 1:3,
nprune = seq(2, 50, length.out = 10) %>%
floor())
#make this example reproducible
set.seed(1)
#fit MARS model using k-fold cross-validation
cv_mars <- train(
x = subset(trainmars, select = -c(popularity)),
y = train$popularity,
method = "earth",
metric = "RMSE",
trControl = trainControl(method = "cv", number = 10),
tuneGrid = hyper_grid)
trainmars <- train
# implementation of MARS method
# divide dataset into k pieces
# fit a regression model to each piece
# use k-fold cross validation to choose a value for k
# using train
#create a tuning grid
hyper_grid <- expand.grid(degree = 1:3,
nprune = seq(2, 50, length.out = 10) %>%
floor())
#make this example reproducible
set.seed(1)
#fit MARS model using k-fold cross-validation
cv_mars <- train(
x = subset(trainmars, select = -c(popularity)),
y = train$popularity,
method = "earth",
metric = "RMSE",
trControl = trainControl(method = "cv", number = 10),
tuneGrid = hyper_grid)
music <- read.csv("/Users/kimbauer/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv")
View(music)
# New research question: can we predict if a song will be a hit based on its attributes? Response variable: song.hotttnesss
# anna path name: /Users/kimbauer/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/data_w_genres.csv
# creating a new numeric variable for specific artist average popularity
artist_pop_table <- aggregate(music$popularity, list(music$artists), FUN = mean)
full_merge <- merge(x = music, y = artist_pop_table, by.x = c("artists"), by.y = c("Group.1"), all.x = TRUE)
full_data <- rename(full_merge, avg_art_pop = x)
View(full_data)
set.seed((666))
# sample data to use for exploratory graphics
sample <- full_data[sample(nrow(full_data), 200), ]
View(sample)
# modifying our full data to leave out the variables we don't want
full_data$popularity <- as.numeric(full_data$popularity)
full_data$year <- as.numeric(full_data$year)
full_data$duration_ms <- as.numeric(full_data$duration_ms)
full_data2 = full_data %>%
mutate(explicit = as.factor(ifelse(explicit == 0, "Clean", "Explicit"))) %>%
mutate(mode = as.factor(ifelse(mode == 0, "Minor", "Major")))
delete <- c("artists", "id", "key", "name", "release_date")
full_data <- full_data[!(names(full_data) %in% delete)]
# split training and testing data
#set seed
set.seed(123)
# Sample 700 observations as training data
trainsample = sort(sample(nrow(full_data), nrow(full_data)*.7))
# define dat.train as the 700 observstions
train = full_data[trainsample,]
# The rest as test data
test = full_data[-trainsample,]
trainmars <- train
# implementation of MARS method
# divide dataset into k pieces
# fit a regression model to each piece
# use k-fold cross validation to choose a value for k
# using train
#create a tuning grid
hyper_grid <- expand.grid(degree = 1:3,
nprune = seq(2, 50, length.out = 10) %>%
floor())
#make this example reproducible
set.seed(1)
#fit MARS model using k-fold cross-validation
cv_mars <- train(
x = subset(trainmars, select = -c(popularity)),
y = train$popularity,
method = "earth",
metric = "RMSE",
trControl = trainControl(method = "cv", number = 10),
tuneGrid = hyper_grid)
#display model with lowest test RMSE
cv_mars$results %>%
filter(nprune==cv_mars$bestTune$nprune, degree =cv_mars$bestTune$degree)
#display model with lowest test RMSE
cv_mars$results %>%
filter(nprune= cv_mars$bestTune$nprune, degree = cv_mars$bestTune$degree)
library(spotifyr)
library(tidyverse)
library(tidymodels)
library(knitr)
library(lubridate)
library(httpuv)
library(cluster)
library(factoextra)
library(data.table)
library(dplyr)
library(ggplot2)
library(BART)
library(gbm)
library(kknn)
library(earth)
library(caret)
library(FNN)
library("ggpubr")
theme_set(
theme_bw() +
theme(legend.position = "top")
)
music <- read.csv("/Users/kimbauer/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv")
View(music)
# New research question: can we predict if a song will be a hit based on its attributes? Response variable: song.hotttnesss
# anna path name: /Users/kimbauer/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/data_w_genres.csv
# creating a new numeric variable for specific artist average popularity
artist_pop_table <- aggregate(music$popularity, list(music$artists), FUN = mean)
full_merge <- merge(x = music, y = artist_pop_table, by.x = c("artists"), by.y = c("Group.1"), all.x = TRUE)
full_data <- rename(full_merge, avg_art_pop = x)
# creating a new numeric variable for specific artist average popularity
artist_pop_table <- aggregate(music$popularity, list(music$artists), FUN = mean)
full_merge <- merge(x = music, y = artist_pop_table, by.x = c("artists"), by.y = c("Group.1"), all.x = TRUE)
full_data <- rename(full_merge, avg_art_pop = x)
set.seed((666))
# sample data to use for exploratory graphics
sample <- full_data[sample(nrow(full_data), 200), ]
# modifying our full data to leave out the variables we don't want
full_data$popularity <- as.numeric(full_data$popularity)
full_data$year <- as.numeric(full_data$year)
full_data$duration_ms <- as.numeric(full_data$duration_ms)
full_data2 = full_data %>%
mutate(explicit = as.factor(ifelse(explicit == 0, "Clean", "Explicit"))) %>%
mutate(mode = as.factor(ifelse(mode == 0, "Minor", "Major")))
delete <- c("artists", "id", "key", "name", "release_date")
full_data <- full_data[!(names(full_data) %in% delete)]
# split training and testing data
#set seed
set.seed(123)
# Sample 700 observations as training data
trainsample = sort(sample(nrow(full_data), nrow(full_data)*.7))
# define dat.train as the 700 observstions
train = full_data[trainsample,]
# The rest as test data
test = full_data[-trainsample,]
#display model with lowest test RMSE
cv_mars$results %>%
filter(nprune= cv_mars$bestTune$nprune, degree = cv_mars$bestTune$degree)
#display model with lowest test RMSE
cv_mars$results %>%
filter(nprune == cv_mars$bestTune$nprune, degree = cv_mars$bestTune$degree)
#display model with lowest test RMSE
cv_mars$results %>%
filter(nprune == cv_mars$bestTune$nprune, degree = cv_mars$bestTune$degree)
#display model with lowest test RMSE
cv_mars$results %>%
filter(nprune == cv_mars$bestTune$nprune, degree == cv_mars$bestTune$degree)
#display test RMSE by terms and degree
ggplot(cv_mars)
# some EDA plots
valence <- ggplot(sample, aes(x=valence, y=popularity)) + geom_point(color = "seagreen1") + geom_smooth(se = FALSE, color = "black")
library(spotifyr)
library(tidyverse)
library(tidymodels)
library(knitr)
library(lubridate)
library(httpuv)
library(cluster)
library(factoextra)
library(data.table)
library(dplyr)
library(ggplot2)
library(BART)
library(gbm)
library(kknn)
library(earth)
library(caret)
library(FNN)
library("ggpubr")
theme_set(
theme_bw() +
theme(legend.position = "top")
)
music <- read.csv("/Users/lexnavarra/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv")
music <- read.csv("/Users/Grant/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv")
# New research question: can we predict if a song will be a hit based on its attributes? Response variable: song.hotttnesss
# anna path name: /Users/kimbauer/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/data_w_genres.csv
library(spotifyr)
library(tidyverse)
library(tidymodels)
library(knitr)
library(lubridate)
library(httpuv)
library(cluster)
library(factoextra)
library(data.table)
library(dplyr)
library(ggplot2)
library(BART)
library(gbm)
library(kknn)
library(earth)
library(caret)
library(FNN)
library("ggpubr")
theme_set(
theme_bw() +
theme(legend.position = "top")
)
music <- read.csv("/Users/Grant/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv")
# New research question: can we predict if a song will be a hit based on its attributes? Response variable: song.hotttnesss
# anna path name: /Users/kimbauer/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/data_w_genres.csv
# randomly subset syntax, with 100 points (couldnt run this due to the file not loading)
# anna path name music: /Users/kimbauer/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv
# anna path name music w genre: /Users/kimbauer/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/data_w_genres.csv
# grant path name music: /Users/Grant/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv
# grant path name music w genre: /Users/Grant/DoubleProjectGroup/131 Project/Spotify Dataset/data_w_genres.csv
# lex path name music: /Users/lexnavarra/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv
# lex path name music w genre: /Users/lexnavarra/Desktop/DoubleProjectGroup/131 Project/Spotify Dataset/data_w_genres.csv
# creating a new numeric variable for specific artist average popularity
artist_pop_table <- aggregate(music$popularity, list(music$artists), FUN = mean)
full_merge <- merge(x = music, y = artist_pop_table, by.x = c("artists"), by.y = c("Group.1"), all.x = TRUE)
full_data <- rename(full_merge, avg_art_pop = x)
set.seed((666))
# sample data to use for exploratory graphics
sample <- full_data[sample(nrow(full_data), 200), ]
knitr::opts_chunk$set(echo = TRUE)
# mutate our dummy variables into as.factor
music = music %>%
mutate(explicit = as.factor(ifelse(explicit == 0, "Clean", "Explicit"))) %>%
mutate(mode = as.factor(ifelse(mode == 0, "Minor", "Major")))
set.seed((123))
# sample data to use for exploratory graphics
sample <- full_data[sample(nrow(full_data), 200), ]
valence <- ggplot(sample, aes(x=valence, y=popularity)) + geom_point(color = "seagreen1") + geom_smooth(se = FALSE, color = "black")
year <- ggplot(sample, aes(x=year, y = popularity)) + geom_point(color = "dodgerblue2") + geom_smooth(se = FALSE, color = "black")
acousticness <- ggplot(sample, aes(x=acousticness, y=popularity)) + geom_point(col = "mediumpurple1")
danceability <- ggplot(sample, aes(x=danceability, y=popularity)) + geom_point(col = "lightpink") + geom_smooth(se = FALSE, color = "black")
duration <- ggplot(sample, aes(x=duration_ms, y=popularity)) + geom_point(col = "sienna1")
energy <- ggplot(sample, aes(x=energy, y=popularity)) + geom_point(col = "firebrick3") + geom_smooth(se = FALSE, color = "black")
explicit <- ggplot(sample, aes(x=explicit)) + geom_bar(fill = "darkseagreen") + scale_x_continuous(breaks = c(0,1), labels=c("0" = "Clean", "1" = "Explicit"))
instrumentalness <- ggplot(sample, aes(x=instrumentalness, y=popularity)) + geom_point(col = "goldenrod1")
liveness <- ggplot(sample, aes(x=liveness, y=popularity)) + geom_point(col = "deeppink1")
loudness <- ggplot(sample, aes(x=loudness, y=popularity)) + geom_point(col = "khaki1") + geom_smooth(se = FALSE, color = "black")
mode <- ggplot(sample, aes(x=mode)) + geom_bar(fill = "plum") + scale_x_continuous(breaks=0:1,
labels=c("Minor", "Major"))
speechiness <- ggplot(sample, aes(x=speechiness, y=popularity)) + geom_point(col = "green4") + geom_smooth(se = FALSE, color = "black")
tempo <- ggplot(sample, aes(x=tempo, y=popularity)) + geom_point(col = "springgreen")
avg_art_pop <- ggplot(sample, aes(x=avg_art_pop, y=popularity)) + geom_point(col = "deepskyblue") + geom_smooth(se = FALSE, color = "black")
# making a figure to display all of our EDA plots
figure <- ggarrange(valence, year, acousticness, danceability, duration, energy, explicit, instrumentalness, liveness, loudness, mode, speechiness, tempo, avg_art_pop, ncol = 3, nrow = 5)
figure
# list all packages here
library(tidyverse)
library(knitr)
library(lubridate)
library(httpuv)
library(cluster)
library(factoextra)
library(data.table)
library(dplyr)
library(ggplot2)
# load music.csv
music <- read.csv("/Users/Grant/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv")
# music.csv preview
head(music)
library(ggplot2)
# making a figure to display all of our EDA plots
figure <- ggarrange(valence, year, acousticness, danceability, duration, energy, explicit, instrumentalness, liveness, loudness, mode, speechiness, tempo, avg_art_pop, ncol = 3, nrow = 5)
figure
# making some of the int variables into numeric
full_data$popularity <- as.numeric(full_data$popularity)
full_data$year <- as.numeric(full_data$year)
full_data$duration_ms <- as.numeric(full_data$duration_ms)
# mutating dummy variables
full_data2 = full_data %>%
mutate(explicit = as.factor(ifelse(explicit == 0, "Clean", "Explicit"))) %>%
mutate(mode = as.factor(ifelse(mode == 0, "Minor", "Major")))
# modifying our full data to leave out the variables we don't want
delete <- c("artists", "id", "key", "name", "release_date")
full_data <- full_data[!(names(full_data) %in% delete)]
# correlation matrix and heatmap
# library(corrplot)
corr_mat <- cor(full_data)
corr_mat[, 12]
corrplot(corr_mat, type = "lower", order = "hclust", tl.col = "black", tl.srt = 45)
library(spotifyr)
library(tidyverse)
library(tidymodels)
library(knitr)
library(lubridate)
library(httpuv)
library(cluster)
library(factoextra)
library(data.table)
library(dplyr)
library(ggplot2)
library(BART)
library(gbm)
library(kknn)
library(earth)
library(caret)
library(FNN)
library("ggpubr")
library(corrplot)
theme_set(
theme_bw() +
theme(legend.position = "top")
)
# list all packages here
library(tidyverse)
library(knitr)
library(lubridate)
library(httpuv)
library(cluster)
library(factoextra)
library(data.table)
library(dplyr)
library(ggplot2)
library(corrplot)
# load music.csv
music <- read.csv("/Users/Grant/DoubleProjectGroup/131 Project/Spotify Dataset/musicdata.csv")
# music.csv preview
head(music)
# correlation matrix and heatmap
# library(corrplot)
corr_mat <- cor(full_data)
corr_mat[, 12]
corrplot(corr_mat, type = "lower", order = "hclust", tl.col = "black", tl.srt = 45)
# correlation matrix and heatmap
# library(corrplot)
corr_mat <- cor(full_data)
corr_mat[, 12]
corrplot(corr_mat, type = "lower", order = "hclust", tl.col = "black", tl.srt = 45)
valence <- ggplot(sample, aes(x=valence, y=popularity)) + geom_point(color = "seagreen1") + geom_smooth(se = FALSE, color = "black")
year <- ggplot(sample, aes(x=year, y = popularity)) + geom_point(color = "dodgerblue2") + geom_smooth(se = FALSE, color = "black")
acousticness <- ggplot(sample, aes(x=acousticness, y=popularity)) + geom_point(col = "mediumpurple1")
danceability <- ggplot(sample, aes(x=danceability, y=popularity)) + geom_point(col = "lightpink") + geom_smooth(se = FALSE, color = "black")
duration <- ggplot(sample, aes(x=duration_ms, y=popularity)) + geom_point(col = "sienna1")
energy <- ggplot(sample, aes(x=energy, y=popularity)) + geom_point(col = "firebrick3") + geom_smooth(se = FALSE, color = "black")
explicit <- ggplot(sample, aes(x=explicit)) + geom_bar(fill = "darkseagreen") + scale_x_continuous(breaks = c(0,1), labels=c("0" = "Clean", "1" = "Explicit"))
instrumentalness <- ggplot(sample, aes(x=instrumentalness, y=popularity)) + geom_point(col = "goldenrod1")
key <- ggplot(sample, aes(x=key)) + geom_bar(fill = "darkslategray3") + scale_x_continuous(breaks=0:11,
labels=c("C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"))
liveness <- ggplot(sample, aes(x=liveness, y=popularity)) + geom_point(col = "deeppink1")
loudness <- ggplot(sample, aes(x=loudness, y=popularity)) + geom_point(col = "khaki1") + geom_smooth(se = FALSE, color = "black")
mode <- ggplot(sample, aes(x=mode)) + geom_bar(fill = "plum") + scale_x_continuous(breaks=0:1,
labels=c("Minor", "Major"))
speechiness <- ggplot(sample, aes(x=speechiness, y=popularity)) + geom_point(col = "green4") + geom_smooth(se = FALSE, color = "black")
tempo <- ggplot(sample, aes(x=tempo, y=popularity)) + geom_point(col = "springgreen")
avg_art_pop <- ggplot(sample, aes(x=avg_art_pop, y=popularity)) + geom_point(col = "deepskyblue") + geom_smooth(se = FALSE, color = "black")
library(ggplot2)
# making a figure to display all of our EDA plots
figure <- ggarrange(valence, year, acousticness, danceability, duration, energy, explicit, instrumentalness, liveness, loudness, mode, speechiness, tempo, avg_art_pop, ncol = 3, nrow = 5)
figure
library(ggplot2)
# making a figure to display all of our EDA plots
figure <- ggarrange(valence, year, acousticness, danceability, duration, energy, explicit, instrumentalness, key, liveness, loudness, mode, speechiness, tempo, avg_art_pop, ncol = 3, nrow = 5)
figure
# adding a density histogram for our outcome variable popularity
hist <- ggplot(full_data) +
ggtitle("Density Histogram for Outcome Varible") + # include title
geom_histogram(aes(popularity, y = after_stat(density)), binwidth = 5, fill = "cyan", color = "grey")  # add histogram w density
x <- seq(0, 100, length.out = 100)
df <- with(full_data, data.frame(x=x, y = dnorm(x, mean(popularity), sd(popularity))))
hist + geom_line(data = df, aes(x = x, y = y), color = "red")
library(ggplot2)
# making a figure to display all of our EDA plots
figure <- ggarrange(valence, year, acousticness, danceability, duration, energy, explicit, instrumentalness, key, liveness, loudness, mode, speechiness, tempo, avg_art_pop, ncol = 3, nrow = 5)
figure
library(ggplot2)
# making a figure to display all of our EDA plots
figure <- multiplot(valence, year, acousticness, danceability, duration, energy, explicit, instrumentalness, key, liveness, loudness, mode, speechiness, tempo, avg_art_pop, ncol = 3, nrow = 5)
library(ggplot)
install.packages('ggplot')
library(ggplot2)
# making a figure to display all of our EDA plots
figure <- ggarrange(valence, year, acousticness, danceability, duration, energy, explicit, instrumentalness, key, liveness, loudness, mode, speechiness, tempo, avg_art_pop, ncol = 3, nrow = 5)
figure
remove.packages('ggplot2')
install.packages('ggplot2', dependencies = TRUE)
library(ggplot2)
# making a figure to display all of our EDA plots
figure <- ggarrange(valence, year, acousticness, danceability, duration, energy, explicit, instrumentalness, key, liveness, loudness, mode, speechiness, tempo, avg_art_pop, ncol = 3, nrow = 5)
figure
knitr::opts_chunk$set(echo = TRUE)
install.packages('ggplot2', dependencies = TRUE)
library(ggplot2)
# making a figure to display all of our EDA plots
figure <- ggarrange(valence, year, acousticness, danceability, duration, energy, explicit, instrumentalness, key, liveness, loudness, mode, speechiness, tempo, avg_art_pop, ncol = 3, nrow = 5)
install.packages('ggplot2', dependencies = TRUE)
library(ggplot2)
# making a figure to display all of our EDA plots
figure <- ggarrange(valence, year, acousticness, danceability, duration, energy, explicit, instrumentalness, key, liveness, loudness, mode, speechiness, tempo, avg_art_pop, ncol = 3, nrow = 5)
library(ggplot2)
# making a figure to display all of our EDA plots
figure <- ggarrange(valence, year, acousticness, danceability, duration, energy, explicit, instrumentalness, key, liveness, loudness, mode, speechiness, tempo, avg_art_pop, ncol = 3, nrow = 5)
install.packages("ggplot2", dependencies=TRUE)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
# making a figure to display all of our EDA plots
figure <- ggarrange(valence, year, acousticness, danceability, duration, energy, explicit, instrumentalness, key, liveness, loudness, mode, speechiness, tempo, avg_art_pop, ncol = 3, nrow = 5)
library(ggpubr)
# making a figure to display all of our EDA plots
figure <- ggarrange(valence, year, acousticness, danceability, duration, energy, explicit, instrumentalness, key, liveness, loudness, mode, speechiness, tempo, avg_art_pop, ncol = 3, nrow = 5)
library(ggpubr)
# making a figure to display all of our EDA plots
figure <- ggarrange(valence, year, acousticness, danceability, duration, energy, explicit, instrumentalness, key, liveness, loudness, mode, speechiness, tempo, avg_art_pop, ncol = 3, nrow = 5)
library('ggpubr')
# making a figure to display all of our EDA plots
figure <- ggarrange(valence, year, acousticness, danceability, duration, energy, explicit, instrumentalness, key, liveness, loudness, mode, speechiness, tempo, avg_art_pop, ncol = 3, nrow = 5)
install.packages("ggpubr")
knitr::opts_chunk$set(echo = TRUE)
library(ggpubr)
# making a figure to display all of our EDA plots
figure <- ggarrange(valence, year, acousticness, danceability, duration, energy, explicit, instrumentalness, key, liveness, loudness, mode, speechiness, tempo, avg_art_pop, ncol = 3, nrow = 5)
